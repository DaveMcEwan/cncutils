#!/usr/bin/env python
# Everything is always in millimeters, not stupid imperial!
# Jog machine to desired location then run the output generated by this script.

from gcode_base import *
from gcode_profile_polygon import *
from math_base import *

def cherrymx_keycross_points(
                    height=4.0,
                    width=4.0,
                    height_thk=1.1,
                    width_thk=1.3,
                    endmill=1.0,
                   ): # {{{
    '''Generate points for polygon used for making CherryMX cross holes for keycaps.
    '''

    assert isinstance(width, float) and width > 0.0
    
    # Calculate points to move to.
    inner_x = height_thk/2 - endmill/2
    outer_x = width/2 - endmill/2
    inner_y = width_thk/2 - endmill/2
    outer_y = height/2 - endmill/2
    
    # Points relative to centre listed in CW direction.
    pts = [
           # Up spar
           (-inner_x, +inner_y),
           (-inner_x, +outer_y),
           (+inner_x, +outer_y),
           
           # Right spar
           (+inner_x, +inner_y),
           (+outer_x, +inner_y),
           (+outer_x, -inner_y),
           
           # Down spar
           (+inner_x, -inner_y),
           (+inner_x, -outer_y),
           (-inner_x, -outer_y),
           
           # Left spar
           (-inner_x, -inner_y),
           (-outer_x, -inner_y),
           (-outer_x, +inner_y),
           (-inner_x, +inner_y),
          ]
    
    return pts
# }}}

def cherrymx_keycross_profile(
                     height=4.0,
                     width=4.0,
                     height_thk=1.1,
                     width_thk=1.3,
                     depth=3.0,
                     pitch=1.0,
                     feedrate=660.0,
                     plungerate=500.0,
                     clearance=5.0,
                     endmill=1.0,
                     direction='ccw',
                     ablpd=True,
                    ): # {{{
    '''Generate gcode for a hole at the current position to hold cherry mx keystem.
    '''

    assert isinstance(width, float) and width > 0.0
    assert isinstance(height, float) and height > 0.0
    assert isinstance(depth, float) and depth > 0.0
    assert isinstance(pitch, float) and pitch > 0.0
    assert isinstance(feedrate, float) and feedrate > 0.0
    assert isinstance(plungerate, float) and plungerate > 0.0
    assert isinstance(clearance, float) and clearance > 0.0
    # Endmill size > 0 assertion not needed as you may want to just generate a
    #   "dumb" path for a different shape of endmill.
    assert isinstance(endmill, float) and endmill < width
    assert isinstance(direction, str) and direction in ['cw', 'ccw']
    assert isinstance(ablpd, bool)
    
    pts = cherrymx_keycross_points(height, width, height_thk, width_thk, endmill)
    
    # Initialise gcode lines.
    g = []
    
    # Set units as millimeters.
    g.append('G21')
    
    # Use relative positioning (as opposed to absolute).
    # Required to make this code callable like a function.
    g.append('G91')
    
    g.append(polygon_profile(
                             pts=pts,
                             depth=depth,
                             pitch=pitch,
                             feedrate=feedrate,
                             plungerate=plungerate,
                             clearance=clearance,
                             ablpd=ablpd,
                            ))
    
    return '\n'.join(g)
# }}}


if __name__ == '__main__':
    import argparse
    
    parser = argparse.ArgumentParser()
    
    parser.add_argument('--height',
                        action='store',
                        default=4.0,
                        type=float,
                        help='cross height')
    
    parser.add_argument('--width',
                        action='store',
                        default=4.0,
                        type=float,
                        help='cross width')
    
    parser.add_argument('--height_thk',
                        action='store',
                        default=1.1,
                        type=float,
                        help='Thickness of up/down spars')
    
    parser.add_argument('--width_thk',
                        action='store',
                        default=1.3,
                        type=float,
                        help='Thickness of left/right spars')
    
    parser.add_argument('--depth',
                        action='store',
                        default=3.0,
                        type=float,
                        help='cross depth')
    
    parser.add_argument('--pitch',
                        action='store',
                        default=1.0,
                        type=float,
                        help='cutting pitch')
    
    parser.add_argument('--feedrate',
                        action='store',
                        default=100.0,
                        type=float,
                        help='feedrate (mm/minute)')
    
    parser.add_argument('--plungerate',
                        action='store',
                        default=100.0,
                        type=float,
                        help='plungerate (mm/minute)')
    
    parser.add_argument('--clearance',
                        action='store',
                        default=5.0,
                        type=float,
                        help='clearance (mm)')
    
    parser.add_argument('--endmill',
                        action='store',
                        default=1.0,
                        type=float,
                        help='endmill diameter (cylindrical)')
    
    parser.add_argument('--direction',
                        action='store',
                        default='cw',
                        choices=['cw', 'ccw'],
                        help='cutting direction')
    
    parser.add_argument('--ablpd',
                        action='store',
                        default=1,
                        type=int,
                        choices=[0, 1],
                        help='Anti Backlash Point Drilling')

    args = parser.parse_args()
    
    # Initialise gcode lines.
    g = []
    
    # Select XY plane.
    g.append('G17')
    
    # Set units as millimeters.
    g.append('G21')
    
    # Assume spindle starts at zero.
    g.append('G91 G0 Z%s' % floatf(args.clearance))
    
    # Cherry profile function should assume spindle at clearance.
    g.append(cherrymx_keycross_profile(
                              height=args.height,
                              width=args.width,
                              height_thk=args.height_thk,
                              width_thk=args.width_thk,
                              depth=args.depth,
                              pitch=args.pitch,
                              feedrate=args.feedrate,
                              plungerate=args.plungerate,
                              clearance=args.clearance,
                              endmill=args.endmill,
                              direction=args.direction,
                              ablpd=bool(args.ablpd),
                             ))
    # Cherry profile function should leave spindle at clearance.

    # Put gcode onto STDOUT to let caller do any file redirect.
    print('\n'.join(g))
